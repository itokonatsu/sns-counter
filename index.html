<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>SNS文字数カウント</title>
  <!-- Tailwind CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @keyframes shake {
      10%, 90% { transform: translateX(-1px); }
      20%, 80% { transform: translateX(2px); }
      30%, 50%, 70% { transform: translateX(-4px); }
      40%, 60% { transform: translateX(4px); }
    }
    .shake { animation: shake 0.35s ease-in-out; }
  </style>
</head>
<body class="min-h-screen bg-gray-50 text-gray-800">
  <div class="max-w-3xl mx-auto p-6">
    <header class="mb-6">
      <h1 class="text-2xl font-bold">SNS文字数カウント</h1>
      <p class="text-sm text-gray-500 mt-1">到達したら色が変わる簡易アラートつき（全ての文字・改行をカウント）</p>
    </header>

    <!-- 設定 -->
    <section class="mb-4">
      <div class="flex flex-wrap items-end gap-4">
        <label class="block">
          <span class="text-sm font-medium text-gray-700">エラーを出す文字数</span>
          <input id="limitInput" type="number" min="1" step="1" placeholder="例: 140"
                 class="mt-1 w-40 rounded-xl border border-gray-300 px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
                 />
        </label>
        <label class="flex items-center gap-2 text-sm text-gray-700">
          <input id="beepToggle" type="checkbox" class="rounded border-gray-300">
          到達時に軽く振動（デスクトップは視覚のみ）
        </label>
        <button id="resetBtn"
                class="ml-auto rounded-xl border px-3 py-2 text-sm hover:bg-gray-100">
          リセット
        </button>
      </div>
    </section>

    <!-- 入力欄 -->
    <section>
      <div id="editorWrap"
           class="rounded-2xl border border-gray-300 bg-white shadow-sm focus-within:ring-2 focus-within:ring-blue-500 transition">
        <textarea id="textInput" rows="8" placeholder="ここにSNS投稿文を入力…"
                  class="w-full resize-y rounded-2xl p-4 outline-none"
                  ></textarea>
      </div>

      <!-- ステータス -->
      <div class="mt-3 flex flex-wrap items-center gap-4">
        <div class="text-sm">
          <span class="text-gray-600">現在：</span>
          <span id="currentCount" class="font-semibold">0</span>
          <span class="text-gray-600">文字</span>
        </div>
        <div class="text-sm">
          <span class="text-gray-600">残り：</span>
          <span id="remaining" class="font-semibold">-</span>
        </div>
        <div id="reachedBadge"
             class="hidden rounded-full bg-red-100 px-3 py-1 text-xs font-semibold text-red-700">
          しきい値に到達しました
        </div>
        <div class="ml-auto flex gap-2">
          <button id="copyBtn"
                  class="rounded-xl border px-3 py-2 text-sm hover:bg-gray-100">テキストをコピー</button>
          <button id="clearBtn"
                  class="rounded-xl border px-3 py-2 text-sm hover:bg-gray-100">クリア</button>
        </div>
      </div>

      <p id="help" class="mt-2 text-xs text-gray-500">
        ※ 文字数はグラフェム（見た目の1文字）基準でカウント。絵文字や結合文字も直感に近い数で数えます。<br/>
        ※ 到達時のみ色が<span class="font-semibold">赤</span>になります（超えた後も赤のまま）。
      </p>
    </section>
  </div>

  <script>
    // --- ユーティリティ：見た目の1文字（グラフェム）単位でカウント ---
    function countGraphemes(str) {
      try {
        if ('Segmenter' in Intl) {
          const seg = new Intl.Segmenter('ja', { granularity: 'grapheme' });
          let c = 0;
          for (const _ of seg.segment(str)) c++;
          return c;
        }
      } catch (_) {}
      // フォールバック：コードポイントベース
      return Array.from(str).length;
    }

    // DOM
    const limitInput   = document.getElementById('limitInput');
    const textInput    = document.getElementById('textInput');
    const currentCount = document.getElementById('currentCount');
    const remaining    = document.getElementById('remaining');
    const reachedBadge = document.getElementById('reachedBadge');
    const editorWrap   = document.getElementById('editorWrap');
    const resetBtn     = document.getElementById('resetBtn');
    const copyBtn      = document.getElementById('copyBtn');
    const clearBtn     = document.getElementById('clearBtn');
    const beepToggle   = document.getElementById('beepToggle');

    // 永続化キー
    const STORE_KEY = 'sns_counter_settings_v1';

    // 状態
    let limit = null;
    let wasBelow = true;

    // 初期化（保存値の復元）
    (function init() {
      try {
        const saved = JSON.parse(localStorage.getItem(STORE_KEY) || '{}');
        if (typeof saved.limit === 'number') {
          limit = saved.limit;
          limitInput.value = saved.limit;
        }
        if (typeof saved.text === 'string') {
          textInput.value = saved.text;
        }
        if (typeof saved.beep === 'boolean') {
          beepToggle.checked = saved.beep;
        }
      } catch (_) {}
      update();
    })();

    function persist() {
      try {
        localStorage.setItem(STORE_KEY, JSON.stringify({
          limit: limit,
          text: textInput.value,
          beep: beepToggle.checked,
        }));
      } catch (_) {}
    }

    // UI更新
    function update() {
      const text = textInput.value ?? '';
      const count = countGraphemes(text);
      currentCount.textContent = count;

      const limitNum = Number(limit);
      const hasLimit = Number.isFinite(limitNum) && limitNum > 0;

      if (hasLimit) {
        const left = limitNum - count;
        remaining.textContent = left;
        const reached = count >= limitNum;

        // 色と見た目
        textInput.classList.toggle('text-red-600', reached);
        editorWrap.classList.toggle('ring-2', reached);
        editorWrap.classList.toggle('ring-red-500', reached);
        editorWrap.classList.toggle('border-red-400', reached);
        reachedBadge.classList.toggle('hidden', !reached);

        // 到達した瞬間だけ軽い通知（shake / beep）
        if (reached && wasBelow) {
          editorWrap.classList.add('shake');
          setTimeout(() => editorWrap.classList.remove('shake'), 400);
          if (beepToggle.checked && navigator.vibrate) {
            navigator.vibrate(120);
          }
        }
        wasBelow = !reached;
      } else {
        remaining.textContent = '-';
        textInput.classList.remove('text-red-600');
        editorWrap.classList.remove('ring-2', 'ring-red-500', 'border-red-400');
        reachedBadge.classList.add('hidden');
        wasBelow = true;
      }

      persist();
    }

    // イベント
    textInput.addEventListener('input', update);
    limitInput.addEventListener('input', () => {
      const v = Number(limitInput.value);
      limit = Number.isFinite(v) && v > 0 ? v : null;
      update();
    });

    resetBtn.addEventListener('click', () => {
      limitInput.value = '';
      limit = null;
      update();
    });

    copyBtn.addEventListener('click', async () => {
      try {
        await navigator.clipboard.writeText(textInput.value);
        copyBtn.textContent = 'コピーしました';
        setTimeout(() => { copyBtn.textContent = 'テキストをコピー'; }, 1200);
      } catch {
        alert('コピーに失敗しました。');
      }
    });

    clearBtn.addEventListener('click', () => {
      textInput.value = '';
      update();
    });
  </script>
</body>
</html>
